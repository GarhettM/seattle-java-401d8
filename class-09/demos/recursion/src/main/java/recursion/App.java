/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package recursion;

public class App {

    public static void main(String[] args) {
        LinkedList listy = new LinkedList();
        listy.append(99);
        listy.append(98);
        listy.append(97);
        listy.append(96);
        listy.append(95);
        listy.append(94);
//        listy.append(100);
        System.out.println(listy);

        LinkedList listy2 = new LinkedList();
        listy2.append(100);
        listy2.append(101);
        listy2.append(102);
        listy2.append(103);

//        LinkedList combined = new LinkedList();
//        combined.head = LinkedList.mergeIterative(listy, listy2);
//        System.out.println(combined);

        LinkedList comboRecursive = new LinkedList();
        comboRecursive.head = LinkedList.mergeRecursive(listy, listy2);
        System.out.println(comboRecursive);





//        badRecursion();
        betterRecursion(1);
        aLittleBettererRecursion();
//        System.out.println("This is the little better counter : " + littleBetterCounter);
        int outPut = perfectRecursion(0);
//        System.out.println("even better, returns its own counter : " + outPut);
//        System.out.println(count(0, 9000));


    }

    public static void badRecursion(){
        // Reasons this is bad recursion
        // 1. no way to stop : Recursion should always have a way to exit
        // 2. Doesn't do anything meaningful : Recursion should have a purpose
        // 3. Recursion should build on itself :
        // 3b. Recursion should use the accumulated operations to influence its behavior
        badRecursion();
    }

    public static void betterRecursion(int counter){
        if(counter == 10) return;
        counter++;
        betterRecursion(counter);
    }
    static int littleBetterCounter = 1;
    public static void aLittleBettererRecursion(){
        if(littleBetterCounter == 10) return;
        littleBetterCounter++;
        aLittleBettererRecursion();
    }

    static int perfectRecursion(int counter){ // Purpose: count to 10
//        System.out.println(counter);
        if(counter == 10) return counter;
        counter++;
        int theNumIAmCountingTo = perfectRecursion(counter);
        // The magic leap of faith of recursion
        // I make the assumption that calling the function returns 10
        // I assume it fulfills its purpose
        return theNumIAmCountingTo;

//        return evenBetterRecursion(counter);
    }

    static int count(int counter, int target){ // Purpose: count to 10
//        System.out.println(counter);
        if(counter == target) return counter;
        counter++;
        return count(counter, target);
    }


}
